# GasolineCircle
Тестовое задание для UE-разработчика для прохождения в GameBox

## Описание задания
Что нужно сделать

Разработайте соревновательную компьютерную игру на движке Unreal Engine 4 по описанию ниже. При желании реализуйте механики, указанные в разделе «Дополнительные возможности», — это поможет вам набрать больше баллов.

## Описание игры
Появляется меню, в нём два пункта — начать игру и выйти из неё.

### Процесс игры
Игра предназначена для одного человека.
Игровой уровень представляет из себя ограниченную арену. Камера смотрит на уровень сверху вниз и прикреплена к игроку (Top Down). В центре находится игрок с оружием.
Игрок управляет героем с помощью мыши, есть особенности: 
Герой всегда повёрнут в сторону курсора. 
При нажатии на клавиши W, A, S, D происходит управление вперёд, влево, назад, вправо.
На ЛКМ происходит стрельба.
R — перезарядка.

Стрельба происходит как из реального автомата, но долларами: через равные короткие промежутки времени вылетает снаряд, если нажата клавиша мыши. Когда обойма заканчивается, надо перезарядиться (R). Перезарядиться можно в любой момент времени. 
При стрельбе герой тратит патроны и не может стрелять, если патронов нет.

Задача игрока — продержаться три волны наплыва монстров-криптомонет, чтобы его могли эвакуировать рубль и евро.
Всё появление мобов происходит в специальных точках, среди которых точка для спавна очередного NPC выбирается случайно. Однако каждая точка имеет максимальное возможное число заспавненных через неё мобов, и если лимит достигнут, выбирается другая точка.

* 1-я волна: Спавнится T мобов уровня 1 (DOGE)
* 2-я волна: Спавнится U мобов уровня 1 и Z мобов уровня 2 (Ethereum)
* 3-я волна: Спавнится босс в центре карты (Bitcoin)

### Мобы:

* Уровень 1. Мобы размера N1. Бегают со скоростью M1. Наносят урон K1 каждую секунду в радиусе L1. Требуется O1 раз попасть из оружия, чтобы убить.
* Уровень 2. Мобы размера N2. Бегают со скоростью M2. Наносят урон K2 каждую секунду в радиусе L2. Требуется O2 раз попасть из оружия, чтобы убить.
* Босс. Моб размера N3. Бегает со скоростью M3. Наносит урон K3 каждую секунду в полуинтервале радиусов двух сфер: (L3.1; L3.2]. (Если стоять к боссу ближе чем L3.1 или дальше чем L3.2, урон не наносится). Требуется O3 раз попасть из оружия, чтобы убить.
* Все мобы знают, где игрок, и бегают за ним.

Каждый моб с вероятностью V1, V2 и V3 для каждого типа соответственно спавнит монеты (случайное количество [5;10]). В случайное время (5–10 секунд) появляется аукционное предложение: [20;40] патронов за [20;40] монет. Каждую секунду, пока игрок не принимает предложение, стоимость падает на одну монету. Когда игрок принимает предложение, он оплачивает своими монетами, они списываются, патроны добавляются, и через случайное время появляется новое предложение.

### HUD

* Текущая волна.
* Патроны в автомате.
* Патроны в инвентаре.
* Монеты.
* Аукционное предложение.

### Дополнительные возможности реализуют те, кто хочет особенно отличиться и набрать больше баллов. 

* Добавьте эффект screen shake — драматическую тряску камеры при срабатывании мины-ловушки — и эффект медленно покачивающейся камеры.
* Анимируйте мобов.
* Добавьте звуки окружения и действий.
* Добавьте фоновую музыку. Звуки и музыку можно брать со стоковых сервисов вроде freesound.org или audionautix.com. Обращайте внимание на лицензию: вы можете свободно использовать музыку и звуки с пометкой free или common.

### Технические требования
* Игра должна запускаться на платформе Windows или Mac в полноэкранном режиме.
* Размеры героя и предметов примерно одинаковы и равны толщине стен.
* Качество кода должно соответствовать следующим требованиям:
* Код чистый и читабельный. 
* Использованы принципы GamePlay Framework. 
* Отсутствует Delay в тиках и кастомных таймеров.
* Порядок в проекте, который должен соответствовать Unreal Engine 4 Asset Naming Convention.
* Код декомпозирован.
* Присутствуют комментарии.
* Взаимодействие между классами логично (интерфейсы, делегаты там, где нужно).
Оптимизируйте программу:
* Не оставляйте на сцене «мусорные» объекты, которые ничего не делают.
* Не используйте complex collision на сложных объектах.
* По желанию составьте техническую документацию, в которой прописано, за что отвечают разные классы и как они взаимодействуют.
